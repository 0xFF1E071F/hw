** TODO case 0x88: MOV Gb Eb Move

#+BEGIN_SRC javascript
                    mem8 = phys_mem8[physmem8_ptr++];
                    reg_idx1 = (mem8 >> 3) & 7; // ModRM[5-3]:reg
                    x = (regs[reg_idx1 & 3] >> ((reg_idx1 & 4) << 1));
                    if ((mem8 >> 6) == 3) { // ModRM[7-6]:mod
                        reg_idx0 = mem8 & 7;
                        last_tlb_val = (reg_idx0 & 4) << 1;
                        regs[reg_idx0 & 3] = (regs[reg_idx0 & 3] & ~(0xff << last_tlb_val)) | (((x) & 0xff) << last_tlb_val);
                    } else {
                        mem8_loc = segment_translation(mem8);
                        {
                            last_tlb_val = _tlb_write_[mem8_loc >>> 12];
                            if (last_tlb_val == -1) {
                                __st8_mem8_write(x);
                            } else {
                                phys_mem8[mem8_loc ^ last_tlb_val] = x;
                            }
                        }
                    }
                    break EXEC_LOOP;
#+END_SRC

#+BEGIN_SRC c
    case 0x88:
    case 0x89: /* mov Gv, Ev */
        ot = mo_b_d(b, dflag);
        modrm = cpu_ldub_code(env, s->pc++);
        reg = ((modrm >> 3) & 7) | rex_r;

        /* generate a generic store */
        gen_ldst_modrm(env, s, modrm, ot, reg, 1);
        break;
#+END_SRC


* memcode

    function init_segment_local_vars() {
        CS_base = cpu.segs[1].base;//CS
        SS_base = cpu.segs[2].base;//SS
        if (cpu.segs[2].flags & (1 << 22))
            SS_mask = -1;
        else
            SS_mask = 0xffff;
        FS_usage_flag = (((CS_base | SS_base | cpu.segs[3].base | cpu.segs[0].base) == 0) && SS_mask == -1);
        if (cpu.segs[1].flags & (1 << 22)) // D/B â€” Default operation size (0 = 16-bit segment; 1 = 32-bit segment)
            init_CS_flags = 0;
        else
            init_CS_flags = 0x0100 | 0x0080;
    }


* decode MOV MOVE : Vol. 2B 4-35

ModR/M : 2.1
Table 2-2. 32-Bit Addressing Forms with the ModR/M Byte

88 /r MOV r/m8,r8 MR Valid Valid Move r8 to r/m8.
REX + 88 /r MOV r/m8***,r8*** MR Valid N.E. Move r8 to r/m8.

***In 64-bit mode, r/m8 can not be encoded to access the following byte registers if a REX prefix is used: AH, BH, CH, DH.

ModR/M: 7-6:Mod 5-3:Reg/Opcode 2-0:R/M

MR encoding:  
 operand1 : ModRM[2-0]:r/m (w) 
 operand2 : ModRM[5-3]:reg (r) 

control registers: 3A 2.5
segment registers: 3A 3.4.5




* rtl

