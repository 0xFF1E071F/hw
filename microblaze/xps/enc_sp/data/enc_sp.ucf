#
# pin constraints
#
NET A_IO[0] LOC = " G8"  |  IOSTANDARD = "LVCMOS33";
NET A_IO[10] LOC = "H7"  |  IOSTANDARD = "LVCMOS33";
NET A_IO[11] LOC = "G6"  |  IOSTANDARD = "LVCMOS33";
NET A_IO[12] LOC = "D2"  |  IOSTANDARD = "LVCMOS33";
NET A_IO[13] LOC = "D1"  |  IOSTANDARD = "LVCMOS33";
NET A_IO[14] LOC = "F2"  |  IOSTANDARD = "LVCMOS33";
NET A_IO[15] LOC = "F1"  |  IOSTANDARD = "LVCMOS33";
NET A_IO[16] LOC = "L7"  |  IOSTANDARD = "LVCMOS33";
NET A_IO[17] LOC = "K6"  |  IOSTANDARD = "LVCMOS33";
NET A_IO[18] LOC = "N4"  |  IOSTANDARD = "LVCMOS33";
NET A_IO[19] LOC = "N3"  |  IOSTANDARD = "LVCMOS33";
NET A_IO[1] LOC = " E8"  |  IOSTANDARD = "LVCMOS33";
NET A_IO[20] LOC = "H2"  |  IOSTANDARD = "LVCMOS33";
NET A_IO[21] LOC = "H1"  |  IOSTANDARD = "LVCMOS33";
NET A_IO[22] LOC = "P4"  |  IOSTANDARD = "LVCMOS33";
NET A_IO[23] LOC = "P3"  |  IOSTANDARD = "LVCMOS33";
NET A_IO[24] LOC = "L5"  |  IOSTANDARD = "LVCMOS33";
NET A_IO[25] LOC = "K5"  |  IOSTANDARD = "LVCMOS33";
NET A_IO[2] LOC = " B2"  |  IOSTANDARD = "LVCMOS33";
NET A_IO[3] LOC = " A2"  |  IOSTANDARD = "LVCMOS33";
NET A_IO[4] LOC = " E3"  |  IOSTANDARD = "LVCMOS33";
NET A_IO[5] LOC = " E1"  |  IOSTANDARD = "LVCMOS33";
NET A_IO[6] LOC = " C2"  |  IOSTANDARD = "LVCMOS33";
NET A_IO[7] LOC = " C1"  |  IOSTANDARD = "LVCMOS33";
NET A_IO[8] LOC = " F6"  |  IOSTANDARD = "LVCMOS33";
NET A_IO[9] LOC = " F5"  |  IOSTANDARD = "LVCMOS33";
NET B_IO[0] LOC = " J3"  |  IOSTANDARD = "LVCMOS33";
NET B_IO[10] LOC = "N6"  |  IOSTANDARD = "LVCMOS33";
NET B_IO[11] LOC = "P7"  |  IOSTANDARD = "LVCMOS33";
NET B_IO[12] LOC = "U5"  |  IOSTANDARD = "LVCMOS33";
NET B_IO[13] LOC = "V5"  |  IOSTANDARD = "LVCMOS33";
NET B_IO[14] LOC = "R5"  |  IOSTANDARD = "LVCMOS33";
NET B_IO[15] LOC = "T5"  |  IOSTANDARD = "LVCMOS33";
NET B_IO[16] LOC = "U7"  |  IOSTANDARD = "LVCMOS33";
NET B_IO[17] LOC = "V7"  |  IOSTANDARD = "LVCMOS33";
NET B_IO[18] LOC = "T6"  |  IOSTANDARD = "LVCMOS33";
NET B_IO[19] LOC = "V6"  |  IOSTANDARD = "LVCMOS33";
NET B_IO[1] LOC = " J1"  |  IOSTANDARD = "LVCMOS33";
NET B_IO[20] LOC = "H4"  |  IOSTANDARD = "LVCMOS33";
NET B_IO[21] LOC = "H3"  |  IOSTANDARD = "LVCMOS33";
NET B_IO[2] LOC = " K2"  |  IOSTANDARD = "LVCMOS33";
NET B_IO[3] LOC = " K1"  |  IOSTANDARD = "LVCMOS33";
NET B_IO[4] LOC = " T2"  |  IOSTANDARD = "LVCMOS33";
NET B_IO[5] LOC = " T1"  |  IOSTANDARD = "LVCMOS33";
NET B_IO[6] LOC = " U2"  |  IOSTANDARD = "LVCMOS33";
NET B_IO[7] LOC = " U1"  |  IOSTANDARD = "LVCMOS33";
NET B_IO[8] LOC = " N5"  |  IOSTANDARD = "LVCMOS33";
NET B_IO[9] LOC = " P6"  |  IOSTANDARD = "LVCMOS33";
NET Button[0] LOC = "U10"  |  IOSTANDARD = "LVCMOS33";
NET Button[1] LOC = "V10"  |  IOSTANDARD = "LVCMOS33";
NET Button[2] LOC = "R7"  |  IOSTANDARD = "LVCMOS33";
NET Button[3] LOC = "T7"  |  IOSTANDARD = "LVCMOS33";
NET ETHERNET_MDC_pin LOC = "M10"  |  IOSTANDARD = "LVCMOS33";
NET ETHERNET_MDIO LOC = "N9"  |  IOSTANDARD = "LVCMOS33";
NET ETHERNET_PHY_RST_N_pin LOC = "V11"  |  IOSTANDARD = "LVCMOS33"  |  TIG;
NET ETHERNET_RGMII_RXC_pin LOC = "R10"  |  IOSTANDARD = "LVCMOS33";
NET ETHERNET_RGMII_RXD_pin[0] LOC = "T12"  |  IOSTANDARD = "LVCMOS33";
NET ETHERNET_RGMII_RXD_pin[1] LOC = "V12"  |  IOSTANDARD = "LVCMOS33";
NET ETHERNET_RGMII_RXD_pin[2] LOC = "N10"  |  IOSTANDARD = "LVCMOS33";
NET ETHERNET_RGMII_RXD_pin[3] LOC = "P11"  |  IOSTANDARD = "LVCMOS33";
NET ETHERNET_RGMII_RX_CTL_pin LOC = "N11"  |  IOSTANDARD = "LVCMOS33";
NET ETHERNET_RGMII_TXC_pin LOC = "T10"  |  IOSTANDARD = "LVCMOS33"  |  SLEW = "FAST";
NET ETHERNET_RGMII_TXD_pin[0] LOC = "U13"  |  IOSTANDARD = "LVCMOS33"  |  SLEW = "FAST";
NET ETHERNET_RGMII_TXD_pin[1] LOC = "V13"  |  IOSTANDARD = "LVCMOS33"  |  SLEW = "FAST";
NET ETHERNET_RGMII_TXD_pin[2] LOC = "R11"  |  IOSTANDARD = "LVCMOS33"  |  SLEW = "FAST";
NET ETHERNET_RGMII_TXD_pin[3] LOC = "T11"  |  IOSTANDARD = "LVCMOS33"  |  SLEW = "FAST";
NET ETHERNET_RGMII_TX_CTL_pin LOC = "M11"  |  IOSTANDARD = "LVCMOS33"  |  SLEW = "FAST";
NET FTDI_Rx LOC = "L3"  |  IOSTANDARD = "LVCMOS33";
NET FTDI_Tx LOC = "L4"  |  IOSTANDARD = "LVCMOS33";
NET Flash_Clk LOC = "R15"  |  IOSTANDARD = "LVCMOS33";
NET Flash_Cs_N LOC = "V3"  |  IOSTANDARD = "LVCMOS33";
NET Flash_Di LOC = "T13"  |  IOSTANDARD = "LVCMOS33";
NET Flash_Do LOC = "R13"  |  IOSTANDARD = "LVCMOS33";
NET Led_N[0] LOC = "F15"  |  IOSTANDARD = "LVCMOS18";
NET Led_N[1] LOC = "C18"  |  IOSTANDARD = "LVCMOS18";
NET Led_N[2] LOC = "F14"  |  IOSTANDARD = "LVCMOS18";
NET Led_N[3] LOC = "L14"  |  IOSTANDARD = "LVCMOS18";
NET sys_clk LOC = "R8"  |  IOSTANDARD = "LVCMOS33";
NET sys_rst_n LOC = "V9"  |  IOSTANDARD = "LVCMOS33"  |  TIG;
#
# additional constraints
#

NET "sys_clk" TNM_NET = sys_clk_pin;
TIMESPEC TS_sys_clk_pin = PERIOD sys_clk_pin 50000 kHz;


###### Soft Ethernet
# This is a RGMIIv2.0 system
# AXI_STR_*_ACLK is not the same as S_AXI_ACLK from clock generator
# Rx/Tx Client clocks are Rx/Tx PHY clocks so CORE Gen PHY clock constraints propagate to Rx/Tx client clock periods
# Time domain crossing constraints (DATAPATHONLY) are set for maximum bus frequency
# allowed by IP which is the maximum option in BSB. For lower bus frequency choice in BSB,
# the constraints are over constrained. Relaxing them for your system may reduce build time.

NET "*ETHERNET*/S_AXI_ACLK" TNM_NET = "axi4lite_clk";  
NET "*ETHERNET*/AXI_STR_TXD_ACLK" TNM_NET = "axistream_clk"; 
NET "*ETHERNET*/AXI_STR_TXC_ACLK" TNM_NET = "axistream_clk"; 
NET "*ETHERNET*/AXI_STR_RXD_ACLK" TNM_NET = "axistream_clk"; 
NET "*ETHERNET*/AXI_STR_RXS_ACLK" TNM_NET = "axistream_clk"; 

############################################################
# Clock Period Constraints                                 #
############################################################

############################################################
# RX Clock period Constraints                              #
############################################################
# Ethernet RGMII PHY-side receive clock
# Changed NET Name 
# This is a duplicate of TS_rgmii_clk_phy_rx0
#   In this design this is the CLKOUT1 output of mmcm_module_1
#     RGMII_RXC_0 is the name of the clock net at the TEMAC Port
#       It is the input to the BUFG 
#         RxClientClk_0 is the name of the BUFG output clock net 
#           Removed IDELAY due to clock uncertainty   
#			   
#                    |\      
#  ---RGMII_RXC------| >-------rgmii_rx_clk_bufio------------
#                    |/      
#
# Receiver clock period constraints: please do not relax
# Changed NET name TNM_NET, and TIMESPEC names and added TIMEGRP to be consistent 
#  with naming from GMII systems
# NET "*/rx_rgmii_clk_int" TNM_NET  = "clk_rx";
# TIMESPEC "TS_rx_clk" = PERIOD "clk_rx" 8000 ps HIGH 50 %;

NET ETHERNET_RGMII_RXC_pin TNM_NET  = "phy_clk_rx";
TIMEGRP "v6_emac_v1_3_clk_phy_rx" = "phy_clk_rx";
TIMESPEC "TS_rx_clk" = PERIOD "v6_emac_v1_3_clk_phy_rx" 8000 ps HIGH 50 %;

############################################################
# TX Clock period Constraints                              #
############################################################
# Ethernet RGMII PHY-side transmit clock
# Changed NET Name - Input to bufg_tx_0
#     ___________                                          ______   		   
#    |           |                 |\                     |      |  		   
#    | Soft Core |--- TX_CLK_OUT --| >--- Tx_Client_Clk --| ODDR |----RGMII_TXC--
#    |___________|                 |/                     |______|  		   
#                    
# 
# Transmitter clock period constraints: please do not relax
# NET "tx_clk_o" TNM_NET = "phy_clk_tx";
# Changed NET name 

NET ETHERNET_RGMII_TXC_pin TNM_NET = "phy_clk_tx";
TIMEGRP "v6_emac_v1_3_clk_phy_tx" = "phy_clk_tx";
TIMESPEC "TS_v6_emac_v1_3_clk_phy_tx" = PERIOD "v6_emac_v1_3_clk_phy_tx" 8 ns HIGH 50 %;

# Changed NET name TNM_NET, and TIMESPEC names and added TIMEGRP to be consistent 
#  with naming from GMII systems
# NET "gtx_clk*" TNM_NET  = "clk_gtx";
# TIMESPEC "TS_gtx_clk" = PERIOD "clk_gtx" 8000 ps HIGH 50 %;
NET "*clk_125_0000MHz*" TNM_NET = "clk_gtx";
TIMEGRP "gtx_clock" = "clk_gtx";
TIMESPEC "TS_gtx_clk" = PERIOD "gtx_clock" 8000 ps HIGH 50 %;

############################################################
# Host Clock period Constraint                             #
############################################################
# Management Clock period constraints: relax as required
# Changed NET name TNM_NET, and TIMESPEC names and added TIMEGRP to be consistent 
#  with naming from GMII systems
# NET "host_clk" TNM_NET  = "host";
# TIMESPEC "TS_host_clk" = PERIOD "host" 10000 ps HIGH 50 % PRIORITY 10;
NET "*/S_AXI_ACLK" TNM_NET = "host_clock";
TIMEGRP "clk_host" = "host_clock";
TIMESPEC "TS_clk_host" = PERIOD "clk_host" 26.7 ns HIGH 50 %;

############################################################
# The following are required to maximise setup/hold        #
############################################################

INST "*ETHERNET_RGMII_TXD_pin<?>*" SLEW = FAST;
INST "*ETHERNET_RGMII_TX_CTL_pin*" SLEW = FAST;
INST "*ETHERNET_RGMII_TXC_pin*"    SLEW = FAST;

############################################################
# For Setup and Hold time analysis on RGMII inputs         #
############################################################

# Identify RGMII Rx Pads only.  
# This prevents setup/hold analysis being performed on false inputs,
# eg, the configuration_vector inputs.
 INST "*ETHERNET_RGMII_RXD*" TNM = IN_RGMII; 
 INST "*ETHERNET_RGMII_RX_CTL*" TNM = IN_RGMII;
 INST "*S6.rxdata_in_bus[0].delay_rgmii_rxd" TNM = IN_RGMII; 
 INST "*S6.rxdata_in_bus[1].delay_rgmii_rxd" TNM = IN_RGMII; 
 INST "*S6.rxdata_in_bus[2].delay_rgmii_rxd" TNM = IN_RGMII; 
 INST "*S6.rxdata_in_bus[3].delay_rgmii_rxd" TNM = IN_RGMII; 
 INST "*S6.delay_rgmii_rx_ctl*"              TNM = IN_RGMII;

# Set delays for SP605
#INST "*S6.rxdata_in_bus[0].delay_rgmii_rxd" IDELAY_VALUE = 14;
#INST "*S6.rxdata_in_bus[1].delay_rgmii_rxd" IDELAY_VALUE = 14;
#INST "*S6.rxdata_in_bus[2].delay_rgmii_rxd" IDELAY_VALUE = 14;
#INST "*S6.rxdata_in_bus[3].delay_rgmii_rxd" IDELAY_VALUE = 14;
#INST "*S6.delay_rgmii_rx_ctl*"              IDELAY_VALUE = 15;

# The following constraints work in conjunction with DCM PHASE_SHIFT settings to
# check that the RGMII receive bus remains in alignment with the rising and
# falling edges of RGMII_RXC, to within 1.1ns setup time and 1.1ns hold time.
# In addition to adjusting  DCM PHASE_SHIFT settings for your system's timing
# characteristics, you may wish to refine these constraints to match the RGMII
# specification.
# These constraints are not used for spartan6 devices
# Changed to remove TIMEGRP 
# TIMEGRP "IN_RGMII" OFFSET = IN 1.1 ns VALID 2.2 ns BEFORE "Eth_Rxc" RISING;
# TIMEGRP "IN_RGMII" OFFSET = IN 1.1 ns VALID 2.2 ns BEFORE "Eth_Rxc" FALLING;
# Set to allow for 100ps setup/hold trace delay difference in relation to clock
#TIMEGRP "IN_RGMII" OFFSET        = IN 1.1 ns VALID 2.2 ns BEFORE "rgmii_rxc" RISING;
#TIMEGRP "IN_RGMII" OFFSET        = IN 1.1 ns VALID 2.2 ns BEFORE "rgmii_rxc" FALLING;

NET ETHERNET_RGMII_RXD_pin[0] OFFSET = IN 1.1 ns VALID 3 ns BEFORE "ETHERNET_RGMII_RXC_pin" RISING;
NET ETHERNET_RGMII_RXD_pin[0] OFFSET = IN 1.1 ns VALID 3 ns BEFORE "ETHERNET_RGMII_RXC_pin" FALLING;

NET ETHERNET_RGMII_RXD_pin[1] OFFSET = IN 1.1 ns VALID 3 ns BEFORE "ETHERNET_RGMII_RXC_pin" RISING;
NET ETHERNET_RGMII_RXD_pin[1] OFFSET = IN 1.1 ns VALID 3 ns BEFORE "ETHERNET_RGMII_RXC_pin" FALLING;

NET ETHERNET_RGMII_RXD_pin[2] OFFSET = IN 1.1 ns VALID 3 ns BEFORE "ETHERNET_RGMII_RXC_pin" RISING;
NET ETHERNET_RGMII_RXD_pin[2] OFFSET = IN 1.1 ns VALID 3 ns BEFORE "ETHERNET_RGMII_RXC_pin" FALLING;

NET ETHERNET_RGMII_RXD_pin[3] OFFSET = IN 1.1 ns VALID 3 ns BEFORE "ETHERNET_RGMII_RXC_pin" RISING;
NET ETHERNET_RGMII_RXD_pin[3] OFFSET = IN 1.1 ns VALID 3 ns BEFORE "ETHERNET_RGMII_RXC_pin" FALLING;

NET ETHERNET_RGMII_RX_CTL_pin  OFFSET = IN 1.1 ns VALID 3 ns BEFORE "ETHERNET_RGMII_RXC_pin" RISING;
NET ETHERNET_RGMII_RX_CTL_pin  OFFSET = IN 1.1 ns VALID 3 ns BEFORE "ETHERNET_RGMII_RXC_pin" FALLING;

############################################################
# Edge Skew analysis on RGMII inputs                       #
# This will not fail timing but will provide a report of   #
# the clock to data skew - it should be approx -2ns        #
############################################################
# INST "*ETHERNET_RGMII_TXD_pin<?>*" TNM = OUT_RGMII;
# INST "*ETHERNET_RGMII_TX_CTL*" TNM = OUT_RGMII;
# INST "*ETHERNET_RGMII_TXC*"    TNM = OUT_RGMII;
# TIMEGRP "OUT_RGMII" OFFSET = OUT AFTER "*clk_125_0000MHz*" REFERENCE_PIN "ETHERNET_RGMII_RXC_pin" RISING;
# TIMEGRP "OUT_RGMII" OFFSET = OUT AFTER "*clk_125_0000MHz*" REFERENCE_PIN "*ETHERNET_RGMII_RXC*" FALLING;

############################################################
# Crossing of Clock Domain Constraints: please do not edit #
#  In addition to CoreGen constraints                      #
############################################################

# The following TimeSpecs are required only when AXILite clock differs from AXI-Stream clock
# Data path timing depends on the destination clock period
TIMESPEC "TS_axistreamclks_2_axi4liteclks"  = FROM axistream_clk  TO axi4lite_clk   6667 ps  DATAPATHONLY; #assumes axistream_clk <= 150 MHz
TIMESPEC "TS_axi4liteclks_2_axistreamclks"  = FROM axi4lite_clk   TO axistream_clk 20000 ps  DATAPATHONLY; #assumes axi4lite_clk <= 50 MHz

# TNM_NET phy_clk_rx is rx_client_clk
# TIMESPECs for AXI streaming clock crossing to/from rx_client_clk
TIMESPEC "TS_axistreamclks_2_RX_CLIENT_CLK" = FROM axistream_clk  TO phy_clk_rx    8000  ps  DATAPATHONLY; #assumes phy_clk_rx <= 125 MHz
TIMESPEC "TS_RX_CLIENT_CLK_2_axistreamclks" = FROM phy_clk_rx     TO axistream_clk 6667  ps  DATAPATHONLY; #assumes axistream_clk <= 150 MHz
# TIMESPECs for AXI-Lite clock crossing to/from tx_client_clk
TIMESPEC "TS_axi4liteclks_2_RX_CLIENT_CLK"  = FROM axi4lite_clk   TO phy_clk_rx    8000  ps  DATAPATHONLY; #assumes phy_clk_rx <= 125 MHz
TIMESPEC "TS_RX_CLIENT_CLK_2_axi4liteclks"  = FROM phy_clk_rx     TO axi4lite_clk 20000  ps  DATAPATHONLY; #assumes axi4lite_clk <= 50 MHz

# Depending on system configuration, the analysis tool may use either TNM_NET clk_gtx 
#  or TNM_NET phy_clk_tx so only one set will be analyzed
# TNM_NET phy_clk_tx is tx_client_clk
# TIMESPECs for AXI streaming clock crossing to/from tx_client_clk
TIMESPEC "TS_axistreamclks_2_TX_CLIENT_CLK" = FROM axistream_clk  TO phy_clk_tx    8000  ps  DATAPATHONLY; #assumes phy_clk_tx <= 125 MHz
TIMESPEC "TS_TX_CLIENT_CLK_2_axistreamclks" = FROM phy_clk_tx     TO axistream_clk 6667  ps  DATAPATHONLY; #assumes axistream_clk <= 150 MHz
# TIMESPECs for AXI-Lite clock crossing to/from tx_client_clk
TIMESPEC "TS_axi4liteclks_2_TX_CLIENT_CLK"  = FROM axi4lite_clk   TO phy_clk_tx    8000  ps  DATAPATHONLY; #assumes phy_clk_tx <= 125 MHz
TIMESPEC "TS_TX_CLIENT_CLK_2_axi4liteclks"  = FROM phy_clk_tx     TO axi4lite_clk 20000  ps  DATAPATHONLY; #assumes axi4lite_clk <= 50 MHz

# TNM_NET clk_gtx is */GTX_CLK
# TIMESPECs for AXI-Lite clock crossing to/from GTX_CLK
TIMESPEC "TS_axistreamclks_2_GTX_CLK"	    = FROM axistream_clk  TO clk_gtx	   8000  ps  DATAPATHONLY; #assumes clk_gtx <= 125 MHz
TIMESPEC "TS_GTX_CLK_2_axistreamclks"	    = FROM clk_gtx	  TO axistream_clk 6667  ps  DATAPATHONLY; #assumes axistream_clk <= 150 MHz
TIMESPEC "TS_axi4lite_clk_2_GTX_CLK"	    = FROM axi4lite_clk   TO clk_gtx	   8000  ps  DATAPATHONLY; #assumes clk_gtx <= 125 MHz
TIMESPEC "TS_GTX_CLK_2_axi4lite_clk"	    = FROM clk_gtx	  TO axi4lite_clk 20000  ps  DATAPATHONLY; #assumes axi4lite_clk <= 50 MHz

# Depending on system configuration, the analysis tool may use either TNM_NET clk_gtx 
#  or TNM_NET phy_clk_tx so only one set will be analyzed
# Rx Clock crossings - Some paths are analyzed by the TS_flow_rx_to_tx constraint also 
# Needed since ts_resync_flops is commented out
TIMESPEC "TS_RX_CLIENT_CLK_2_TX_CLIENT_CLK" = FROM phy_clk_rx     TO phy_clk_tx    8000  ps  DATAPATHONLY; #assumes phy_clk_tx <= 125 MHz
TIMESPEC "TS_TX_CLIENT_CLK_2_RX_CLIENT_CLK" = FROM phy_clk_tx     TO phy_clk_rx    8000  ps  DATAPATHONLY; #assumes phy_clk_rx <= 125 MHz
TIMESPEC "TS_RX_CLIENT_CLK_2_GTX_CLK"       = FROM phy_clk_rx     TO clk_gtx       8000  ps  DATAPATHONLY; #assumes phy_clk_tx <= 125 MHz
TIMESPEC "TS_GTX_CLK_2_RX_CLIENT_CLK"       = FROM clk_gtx        TO phy_clk_rx    8000  ps  DATAPATHONLY; #assumes phy_clk_rx <= 125 MHz


############################################################################
# VCC AUX VOLTAGE 
############################################################################
CONFIG VCCAUX=3.3;

############################################################################
# Extended MCB performance mode requires a different Vccint specification to
# achieve higher maximum frequencies for DDR2 and DDR3.Consult the Spartan-6
#datasheet (DS162) table 2 and 24 for more information 
############################################################################
CONFIG MCB_PERFORMANCE=EXTENDED;

##################################################################################
# Timing Ignore constraints for paths crossing the clock domain 
##################################################################################
NET "*/mcb_raw_wrapper_inst/selfrefresh_mcb_mode"  TIG;
     
NET "*/mcb_raw_wrapper_inst/gen_term_calib.mcb_soft_calibration_top_inst/mcb_soft_calibration_inst/CKE_Train"  TIG; ##This path exists for DDR2 only

############################################################################
## I/O TERMINATION                                                          
############################################################################
NET "MCB_DDR2_dq[*]"            IN_TERM = NONE;
NET "MCB_DDR2_dqs"              IN_TERM = NONE;
NET "MCB_DDR2_dqs_n"            IN_TERM = NONE;
NET "MCB_DDR2_udqs"             IN_TERM = NONE;
NET "MCB_DDR2_udqs_n"           IN_TERM = NONE;

############################################################################
# DDR2
############################################################################

NET "MCB_DDR2_addr<0>" 		LOC = "H15" | IOSTANDARD = "SSTL18_I";
NET "MCB_DDR2_addr<11>" 	LOC = "G14" | IOSTANDARD = "SSTL18_I";
NET "MCB_DDR2_addr<10>" 	LOC = "E16" | IOSTANDARD = "SSTL18_I";
NET "MCB_DDR2_addr<1>" 		LOC = "H16" | IOSTANDARD = "SSTL18_I";
NET "MCB_DDR2_addr<12>" 	LOC = "D18" | IOSTANDARD = "SSTL18_I";
NET "MCB_DDR2_addr<2>" 		LOC = "F18" | IOSTANDARD = "SSTL18_I";
NET "MCB_DDR2_addr<3>" 		LOC = "J13" | IOSTANDARD = "SSTL18_I";
NET "MCB_DDR2_addr<4>" 		LOC = "E18" | IOSTANDARD = "SSTL18_I";
NET "MCB_DDR2_addr<5>" 		LOC = "L12" | IOSTANDARD = "SSTL18_I";
NET "MCB_DDR2_addr<6>" 		LOC = "L13" | IOSTANDARD = "SSTL18_I";
NET "MCB_DDR2_addr<7>" 		LOC = "F17" | IOSTANDARD = "SSTL18_I";
NET "MCB_DDR2_addr<8>" 		LOC = "H12" | IOSTANDARD = "SSTL18_I";
NET "MCB_DDR2_addr<9>" 		LOC = "G13" | IOSTANDARD = "SSTL18_I";
NET "MCB_DDR2_ba<0>" 		LOC = "H13" | IOSTANDARD = "SSTL18_I";
NET "MCB_DDR2_ba<1>" 		LOC = "H14" | IOSTANDARD = "SSTL18_I";
NET "MCB_DDR2_ba<2>" 		LOC = "K13" | IOSTANDARD = "SSTL18_I";
NET "MCB_DDR2_cas_n" 		LOC = "K16" | IOSTANDARD = "SSTL18_I";
NET "MCB_DDR2_cke" 		LOC = "D17" | IOSTANDARD = "SSTL18_I";
NET "MCB_DDR2_clk" 		LOC = "G16" | IOSTANDARD = "DIFF_SSTL18_I";
NET "MCB_DDR2_clk_n" 		LOC = "G18" | IOSTANDARD = "DIFF_SSTL18_I";
NET "MCB_DDR2_dq<0>" 		LOC = "M16" | IOSTANDARD = "SSTL18_I";
NET "MCB_DDR2_dq<10>" 		LOC = "P17" | IOSTANDARD = "SSTL18_I";
NET "MCB_DDR2_dq<11>" 		LOC = "P18" | IOSTANDARD = "SSTL18_I";
NET "MCB_DDR2_dq<12>" 		LOC = "T17" | IOSTANDARD = "SSTL18_I";
NET "MCB_DDR2_dq<13>" 		LOC = "T18" | IOSTANDARD = "SSTL18_I";
NET "MCB_DDR2_dq<14>" 		LOC = "U17" | IOSTANDARD = "SSTL18_I";
NET "MCB_DDR2_dq<15>" 		LOC = "U18" | IOSTANDARD = "SSTL18_I";
NET "MCB_DDR2_dq<1>" 		LOC = "M18" | IOSTANDARD = "SSTL18_I";
NET "MCB_DDR2_dq<2>" 		LOC = "L17" | IOSTANDARD = "SSTL18_I";
NET "MCB_DDR2_dq<3>" 		LOC = "L18" | IOSTANDARD = "SSTL18_I";
NET "MCB_DDR2_dq<4>" 		LOC = "H17" | IOSTANDARD = "SSTL18_I";
NET "MCB_DDR2_dq<5>" 		LOC = "H18" | IOSTANDARD = "SSTL18_I";
NET "MCB_DDR2_dq<6>" 		LOC = "J16" | IOSTANDARD = "SSTL18_I";
NET "MCB_DDR2_dq<7>" 		LOC = "J18" | IOSTANDARD = "SSTL18_I";
NET "MCB_DDR2_dq<8>" 		LOC = "N17" | IOSTANDARD = "SSTL18_I";
NET "MCB_DDR2_dq<9>" 		LOC = "N18" | IOSTANDARD = "SSTL18_I";
NET "MCB_DDR2_dqs" 		LOC = "K17" | IOSTANDARD = "DIFF_SSTL18_I";
NET "MCB_DDR2_dqs_n" 		LOC = "K18" | IOSTANDARD = "DIFF_SSTL18_I";
NET "MCB_DDR2_ldm" 		LOC = "L16" | IOSTANDARD = "SSTL18_I";
NET "MCB_DDR2_odt" 		LOC = "K14" | IOSTANDARD = "SSTL18_I";
NET "MCB_DDR2_ras_n" 		LOC = "K15" | IOSTANDARD = "SSTL18_I";
NET "MCB_DDR2_udm" 		LOC = "L15" | IOSTANDARD = "SSTL18_I";
NET "MCB_DDR2_udqs" 		LOC = "N15" | IOSTANDARD = "DIFF_SSTL18_I";
NET "MCB_DDR2_udqs_n" 		LOC = "N16" | IOSTANDARD = "DIFF_SSTL18_I";
NET "MCB_DDR2_we_n" 		LOC = "K12" | IOSTANDARD = "SSTL18_I";
NET "MCB_DDR2_rzq" 		LOC = "M13" | IOSTANDARD = "SSTL18_II";
#NET "MCB_DDR2_zio" 		LOC = "P16" | IOSTANDARD = "SSTL18_II";


